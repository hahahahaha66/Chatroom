用户登陆
用户注册

好友管理
好友添加
好友聊天

群聊管理
群聊创建
加入群聊
群聊聊天

好友发送文件
群聊发送文件

使用seq作为相应序号，在发送请求时设置唯一的seq的对应的回调函数，可以设置为unordered——map进行保存，在接受到服务端的响应后，从之前的map表中找到设置的回调函数进行调用，调用完后删除


客户端
登陆 注册

私聊
好友管理
群聊
群聊管理

账户管理


#### 登陆
1输入账户名字和密码 /

#### 注册
2输入要注册的账户名字和密码，密码可以输入两次 /

#### 私聊
3选择私聊的好友
>这里列出所有好友，并附带好友是否在线，是否有新消息
4发送消息

#### 好友管理
5查看好友 /
6添加好友
7删除好友 /
8屏蔽好友
9查看好友申请

#### 群聊
10选择进入的群聊
>列出所有的群聊，显示人数

普通用户
11发送消息
12查看群聊成员

管理员
13查看群聊的加入申请
14移除成员

群主
15设置管理员
16解散群聊

#### 群聊管理
17查看所有的群聊
18创建群聊
>创建时可以指定好友一同加入群聊
19加入群聊
10退出群聊

#### 账户管理
21打印账户信息
22修改密码
23删除账户

---

| 时机             | 获取方式                    | 返回内容             |
| -------------- | ----------------------- | ---------------- |
| ✅ 登录成功时        | 服务端返回用户的好友 / 群聊的 ID 与名字 | 缓存到客户端           |
| ✅ 添加好友 / 加群成功时 | 返回刚添加的好友/群聊的 ID         | 缓存新 ID           |
| ✅ 主动搜索某用户/群    | 提供搜索接口，根据名字查 ID         | 接口返回匹配 ID、昵称、头像等 |

### 使用mysql内部建表结构
用户
id（唯一）
名字
密码
是否在线
建立时间

好友
用户id
好友id
与好友的状态

群聊
id（唯一）
名字
创建时间

群聊成员
群聊id
用户id
用户角色
加入时间

用户聊天记录
id（唯一）
发送者id
接受者id
内容
是否已读
时间戳

群聊天记录
id（唯一）
群聊id
发送者id
内容
时间戳

离线消息表
id（唯一）
接受者id
发送者id
内容
群聊还是私聊
时间戳

### 客户端
初始界面
登陆
注册
退出

#### 进入主界面
私聊
群聊
个人信息
退出

#### 私聊
选择好友聊天
添加好友
好友申请列表
返回上一界面

#### 群聊
选择群聊
创建群聊
退出群聊
返回上一界面

#### 好友聊天
发送消息
屏蔽好友
删除好友
返回上一界面

#### 群聊聊天
成员
发送消息
查看群聊成员
退出群聊

管理员
移除成员
查看申请列表，批准成员

群主
设置管理员
取消管理员
删除群聊

#### 数字与命令
1. 登陆
2. 注册
3. 删除好友
4. 阻塞好友
5. 添加好友
6. 添加群聊
7.  创建群聊
8.  处理好友申请
9.  处理群聊申请
10. 退出群聊
11. 移除群聊成员
12. 删除用户账号
13. 删除群聊
14. 消息
15. 获取私聊历史消息
16. 获取群聊历史消息
17. 设置群聊管理员
18. 取消群聊管理员
19. 当前界面发生变化

#### 被动更新命令格式
负数
1. 删除好友
2. 阻塞好友
3. 添加好友
4. 添加群聊
5. 创建群聊
6. 处理好友申请
7. 处理群聊申请
8. 推出群聊
9. 移出群聊
10. 设置管理员
11. 取消管理员

#### 待解决的问题
*已完成
在客户端登陆成功后，将相关的朋友，群聊，群聊用户信息对应的id和名字发过去

当朋友或群聊发生变化时，通知所有的相关人员，向每一个人发送变化包，来更新状态

就需要设置一个刷新机制，被动接受服务端的刷新包来刷新本地缓存的个人信息

关键点
1. 通知所有相关的在线用户
2. 不在线的用户只在服务端进行修改
3. 尽量做到只通知变化的部分
4. 主动变化端客户端自动修改，被动变化端由服务器发包处理,这里还是分别处理，朋友之间的修改自己处理，涉及群聊的由广播统一修改

*已完成
服务端实现添加群聊处理函数

*已完成
两端实现监视客户端界面实时变化

*已完成
修改群聊创建

*已完成
在数据库读取完所有数据后，将申请人的名字按表填充
切记在从数据库中读取数据时，先读取所有用户信息，在读取申请和朋友信息

*已完成
使用unordered_map缓存message,修改相关函数，主要就是获取历史消息

使用vector并按照时间进行顺序存储，在消息到来时存入service内部的messagelist,并刷新进数据库，同时message内新增string 表示时间

#### 优化点
可以减少一些不必要的发包内容