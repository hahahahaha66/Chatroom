### TCP
TCP连接的建立：三次握手
客户端                   服务端
      ---> SYN 请求连接
    同意连接 SYN + ACK <---
      ---> ACK 回复服务端的SYN

三次握手确保双方接受和发送能力正常，同时在服务端发送SYN和ACK时，就已经为该连接分配资源
此时为半连接状态

TCP连接的断开：四次挥手
客户端                        服务端
      ---> FIN 主动关闭连接
      服务端确认关闭 ACK <---
      服务端断开 FIN <---   
      客户端确认 ACK --->

在一端发送FIN后，进入半关闭状态，表示不再发送数据，但可以接收数据，具体分析如下，客户端发送FIN
表示不再发送数据，服务器收到后先发送ACK,将剩余待发送数据继续发送，发送完毕后在发送FIN关闭连接，
确保双方数据全都发送完毕，其中客户端也对应有两个状态，来确保超时或其他情况下的重传，同时客户端
在最后一个ACK处设置了一个TIME_WAIT，来确保服务端能受到ACK从而真正关闭连接，随后客户端也关闭连接

### 进程
进程是操作系统中资源分配和调度的基本单位，是一个正在运行的程序的实例。
它拥有独立的虚拟地址空间、代码段、数据段、堆栈、文件描述符等资源。
在程序中可以通过fork,exec等来创建，并使用wait/waitpid来回收进程资源
同时进程之间可以通过pipe,内核消息队列，信号，共享内存，套接字等来进行通信

其中，对于fork创建的父子进程之间的资源分配使用了写时复制，子进程看起来拥有父进程的所有内存数据，
但它们共享相同的物理内存页，只有当父或子对某块内存进行写操作时，才会发生实际复制，一下对于资源的具体分类
拷贝：内存空间，代码段，数据段，堆栈，环境变量，命令行参数，信号处理器，用户id，进程间通信资源
共享：文件描述符表，工作目录

注意，进程有两种特殊状态
1. 僵尸进程：子进程结束但父进程未调用 wait，占据资源
2. 孤儿进程：父进程终止但子进程未结束，会被 init（PID 1）或 systemd 领养

进程内存布局 (由低地址到高地址)
+ 程序代码段 存储可执行代码(只读 + 可执行)
+ 只读数据段 字符串常量,const 全局变量
+ 数据段 初始化的全局变量和静态变量
+ BSS段 未初始化的全局变量和静态变量
+ 堆 (heap) `malloc/new` 分配的内存,从低地址向高地址增长
+ 映射区 (mmap 区域) 映射共享库,文件映射,`mmap` 申请的内存等
+ 栈 (stack) 函数调用帧、局部变量，从高地址向低地址增长
+ 内核空间（用户态不可见

其中为了防止栈和堆发生冲突，有以下机制
1. 地址空间隔离，默认堆和栈之间距离很远，中间有 mmap 区
2. rlimit 栈限制，限制栈不能无限扩张，防止“压倒” mmap 或堆
3. sbrk 边界检查，堆不能扩张到 mmap 区或栈区，系统检查地址合法性
4. guard page，栈底设置一页不可访问内存，一旦越界即段错误

### 线程
线程是CPU调度的基本单位，共享进程的地址空间和资源，共享内存直接通信
一个线程一般包含一下部分
线程ID
程序计数器（PC）
寄存器集合
栈（每个线程有独立的栈）
线程局部存储（Thread Local Storage, TLS）

共享部分
程序代码段（text segment）
数据段（global/static 变量）
堆（heap）
文件描述符等资源

在 Linux 中，线程是用 clone() 系统调用创建的，线程本质是特殊的进程（共享更多资源的进程）

### 锁
在C++中提供了不同的锁在不同情况下的使用
1. std::mutex，最基础的互斥量，只允许一个线程访问临界区，需要手动加锁和解锁，并注意使用规范，但开销小
2. std::lock_guard，基于AII 自动管理 mutex 的加锁解锁，代码简洁且安全
3. std::unique_lock，更灵活的使用锁，支持手动加锁，也可以自动加锁，也可以延迟加锁
4. std::shared_mutex，读写锁，支持多个线程并发读，独占写，读多写少场景下效率高
5. std::recursive_mutex，递归锁，允许同一线程多次加锁，必须对应多次解锁，适用于递归函数中使用锁的场景

### 条件变量
条件变量（std::condition_variable）是一种线程同步机制，用于使一个线程等待另一个线程满足某种条件后继续执行
通常用于如下场景：
+ 一个线程等待某个条件变为真（如缓冲区非空）
+ 另一个线程设置该条件并通知等待线程继续执行

但在调节变量的使用过程中会发生虚假唤醒，明明没有满足唤醒条件，线程却被唤醒了
+ 原因

1. 某些平台上的实现允许线程因调度、信号干扰或竞争条件等因素，被错误地唤醒
2. POSIX 标准允许条件变量发生虚假唤醒，避免内核在实现时承担额外的负担来确保 “只在真的满足条件时才唤醒”
3. 线程在 wait() 前没有正确判断条件，或者在 notify 后条件已被其他线程修改，也会导致线程“白醒一场”

+ 解决方法
永远不要相信单次 wait() 的结果，而是搭配条件判断使用 while 循环

### 死锁
死锁是指发生在多个线程互相等待对方释放资源，最终导致程序卡住，永远无法继续执行的现象
只用同时满足以下四个条件才可能发生死锁
1. 互斥条件：线程对所使用的资源至少有一个是不能共享的（如互斥锁）
2. 占有且等待：线程已占有某些资源，同时又在等待其他资源
3. 不剥夺条件：资源不能被强制从占有它的线程中剥夺，只能由该线程主动释放
4. 循环等待：存在一个线程等待资源的循环链，每个线程都在等待下一个线程占有的资源

常见的死锁的场景
1. 多个线程获取多个锁时，获取锁的顺序不一致，可能会造成循环等待
2. 线程获取锁后发生异常或未走到释放逻辑，导致锁长时间不释放，其他线程阻塞
3. 在函数调用中，低层函数再去请求锁，锁之间形成复杂的调用关系，容易造成死锁
4. 果等待线程在 wait() 之前没有获取锁，或 notify 的时机错误，也可能出现死锁
5. 线程同时等待多个资源（例如读写数据库 + 写文件），如果两个线程交叉获取，容易形成死锁

### 智能指针
C++ 提供了三种主要的智能指针，用于自动管理动态分配的资源，防止内存泄漏和悬空指针等问题
1. std::unique_ptr
独占所管理对象的所有权，不能被拷贝（拷贝构造和拷贝赋值被禁用）
支持移动（std::move）转移所有权
离开作用域时自动释放资源

2. std::shared_ptr
多个 shared_ptr 实例可以共享同一资源
内部通过引用计数控制对象生命周期
最后一个引用释放时，自动释放资源

3. std::weak_ptr
不控制资源生命周期，不增加引用计数
与 shared_ptr 搭配使用，解决循环引用问题
可以通过 lock() 方法尝试获取 shared_ptr

### C++的编码原则
1. 单一职责原则（SRP, Single Responsibility Principle）
2. 开闭原则（OCP, Open-Closed Principle） 
3. 接口隔离原则（ISP, Interface Segregation Principle）
4. 遵守 RAII（资源获取即初始化）

### hash
hash是一种将任意长的输入数据，通过一个哈希函数转换为固定长度的输出数据的过程，输出的数据就叫做哈希值
哈希的几个特性
1. 单向性（One-way）
2. 固定长度输出
3. 唯一性（Unique）
4. 高效性（Efficiency）

在使用hash函数时，很难避免不发生hash碰撞，指的是两个不同的键值通过hash函数被映射到同一块值上
hash表常见的应对hash碰撞的方法
1. 链地址法
当发生哈希碰撞时，我们不在哈希表的同一个位置存储新的数据，而是将这个位置变成一个链表，把所有哈希到同一个位置的数据都串联在这个链表上
优点：实现简单，对哈希函数质量要求相对不高
缺点：查找、删除等操作的效率会随着链表长度的增加而降低，如果大量数据哈希到同一个位置，性能会显著下降
2. 开发寻址法
当发生哈希碰撞时，会通过一种特定的“探测”策略来找到下一个可用的槽位
+ 线性探测（Linear Probing）：从碰撞位置开始，依次检查下一个位置，直到找到一个空的槽位
+ 二次探测（Quadratic Probing）：从碰撞位置开始，按照$1^2, 2^2, 3^2...$的步长寻找下一个位置
+ 双重哈希（Double Hashing）：使用另一个哈希函数来计算探测的步长，使探测路径更加随机
优点：无需使用额外的指针，数据局部性更好，有时能提高缓存性能
缺点：删除元素较为复杂，且当哈希表接近满时，性能会急剧下降，容易出现聚集

### muduo
这里主要解释为什么没有将Channel和Tcpconnection合并到一起
首先二者的职责不同
Channel 职责：是文件描述符（如 socket）的事件抽象和事件回调绑定（读/写/错误/关闭）
TcpConnection 职责：封装一个 TCP 连接的生命周期、读写缓冲区、消息回调等

如果将二者合并，首先就是违反了单一职责原则，其次，Channel是通用的事件抽象，并不只是用来Tcpsocket
生命周期的管理也会出现问题，channel的生命周期受Eventloop管理，而Tcpconnection需要精细控制连接的关闭，资源的释放时机

总结一下，当前的设计优势
+ 解耦：Channel 是轻量的、通用的，可以服务于任意 fd，不局限于 TCP
+ 复用：其他模块（如 Acceptor、TimerQueue）也用 Channel
+ 清晰：每个类关注点单一、结构清晰，符合面向对象设计原则

